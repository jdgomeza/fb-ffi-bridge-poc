// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_PLAYEREVENTS_MYGAME_EVENTS_H_
#define FLATBUFFERS_GENERATED_PLAYEREVENTS_MYGAME_EVENTS_H_

#include "flatbuffers/flatbuffers.h"

// Ensure the included flatbuffers.h is the same version as when this file was
// generated, otherwise it may not be compatible.
static_assert(FLATBUFFERS_VERSION_MAJOR == 23 &&
              FLATBUFFERS_VERSION_MINOR == 1 &&
              FLATBUFFERS_VERSION_REVISION == 21,
             "Non-compatible flatbuffers version included");

namespace MyGame {
namespace Events {

struct UUID;

struct Point3D;

struct PlayerSpawn;
struct PlayerSpawnBuilder;
struct PlayerSpawnT;

struct PlayerMoved;
struct PlayerMovedBuilder;
struct PlayerMovedT;

struct PlayerEvent;
struct PlayerEventBuilder;
struct PlayerEventT;

struct EventBatch;
struct EventBatchBuilder;
struct EventBatchT;

enum Event : uint8_t {
  Event_NONE = 0,
  Event_PlayerSpawn = 1,
  Event_PlayerMoved = 2,
  Event_MIN = Event_NONE,
  Event_MAX = Event_PlayerMoved
};

inline const Event (&EnumValuesEvent())[3] {
  static const Event values[] = {
    Event_NONE,
    Event_PlayerSpawn,
    Event_PlayerMoved
  };
  return values;
}

inline const char * const *EnumNamesEvent() {
  static const char * const names[4] = {
    "NONE",
    "PlayerSpawn",
    "PlayerMoved",
    nullptr
  };
  return names;
}

inline const char *EnumNameEvent(Event e) {
  if (::flatbuffers::IsOutRange(e, Event_NONE, Event_PlayerMoved)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEvent()[index];
}

template<typename T> struct EventTraits {
  static const Event enum_value = Event_NONE;
};

template<> struct EventTraits<MyGame::Events::PlayerSpawn> {
  static const Event enum_value = Event_PlayerSpawn;
};

template<> struct EventTraits<MyGame::Events::PlayerMoved> {
  static const Event enum_value = Event_PlayerMoved;
};

template<typename T> struct EventUnionTraits {
  static const Event enum_value = Event_NONE;
};

template<> struct EventUnionTraits<MyGame::Events::PlayerSpawnT> {
  static const Event enum_value = Event_PlayerSpawn;
};

template<> struct EventUnionTraits<MyGame::Events::PlayerMovedT> {
  static const Event enum_value = Event_PlayerMoved;
};

struct EventUnion {
  Event type;
  void *value;

  EventUnion() : type(Event_NONE), value(nullptr) {}
  EventUnion(EventUnion&& u) FLATBUFFERS_NOEXCEPT :
    type(Event_NONE), value(nullptr)
    { std::swap(type, u.type); std::swap(value, u.value); }
  EventUnion(const EventUnion &);
  EventUnion &operator=(const EventUnion &u)
    { EventUnion t(u); std::swap(type, t.type); std::swap(value, t.value); return *this; }
  EventUnion &operator=(EventUnion &&u) FLATBUFFERS_NOEXCEPT
    { std::swap(type, u.type); std::swap(value, u.value); return *this; }
  ~EventUnion() { Reset(); }

  void Reset();

  template <typename T>
  void Set(T&& val) {
    typedef typename std::remove_reference<T>::type RT;
    Reset();
    type = EventUnionTraits<RT>::enum_value;
    if (type != Event_NONE) {
      value = new RT(std::forward<T>(val));
    }
  }

  static void *UnPack(const void *obj, Event type, const ::flatbuffers::resolver_function_t *resolver);
  ::flatbuffers::Offset<void> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr) const;

  MyGame::Events::PlayerSpawnT *AsPlayerSpawn() {
    return type == Event_PlayerSpawn ?
      reinterpret_cast<MyGame::Events::PlayerSpawnT *>(value) : nullptr;
  }
  const MyGame::Events::PlayerSpawnT *AsPlayerSpawn() const {
    return type == Event_PlayerSpawn ?
      reinterpret_cast<const MyGame::Events::PlayerSpawnT *>(value) : nullptr;
  }
  MyGame::Events::PlayerMovedT *AsPlayerMoved() {
    return type == Event_PlayerMoved ?
      reinterpret_cast<MyGame::Events::PlayerMovedT *>(value) : nullptr;
  }
  const MyGame::Events::PlayerMovedT *AsPlayerMoved() const {
    return type == Event_PlayerMoved ?
      reinterpret_cast<const MyGame::Events::PlayerMovedT *>(value) : nullptr;
  }
};

bool VerifyEvent(::flatbuffers::Verifier &verifier, const void *obj, Event type);
bool VerifyEventVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) UUID FLATBUFFERS_FINAL_CLASS {
 private:
  uint64_t a_;
  uint64_t b_;

 public:
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MyGame.Events.UUID";
  }
  UUID()
      : a_(0),
        b_(0) {
  }
  UUID(uint64_t _a, uint64_t _b)
      : a_(::flatbuffers::EndianScalar(_a)),
        b_(::flatbuffers::EndianScalar(_b)) {
  }
  uint64_t a() const {
    return ::flatbuffers::EndianScalar(a_);
  }
  uint64_t b() const {
    return ::flatbuffers::EndianScalar(b_);
  }
};
FLATBUFFERS_STRUCT_END(UUID, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Point3D FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MyGame.Events.Point3D";
  }
  Point3D()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Point3D(float _x, float _y, float _z)
      : x_(::flatbuffers::EndianScalar(_x)),
        y_(::flatbuffers::EndianScalar(_y)),
        z_(::flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return ::flatbuffers::EndianScalar(x_);
  }
  float y() const {
    return ::flatbuffers::EndianScalar(y_);
  }
  float z() const {
    return ::flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Point3D, 12);

struct PlayerSpawnT : public ::flatbuffers::NativeTable {
  typedef PlayerSpawn TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MyGame.Events.PlayerSpawnT";
  }
  std::unique_ptr<MyGame::Events::UUID> player_id{};
  std::unique_ptr<MyGame::Events::Point3D> pos{};
  PlayerSpawnT() = default;
  PlayerSpawnT(const PlayerSpawnT &o);
  PlayerSpawnT(PlayerSpawnT&&) FLATBUFFERS_NOEXCEPT = default;
  PlayerSpawnT &operator=(PlayerSpawnT o) FLATBUFFERS_NOEXCEPT;
};

struct PlayerSpawn FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerSpawnT NativeTableType;
  typedef PlayerSpawnBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MyGame.Events.PlayerSpawn";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_POS = 6
  };
  const MyGame::Events::UUID *player_id() const {
    return GetStruct<const MyGame::Events::UUID *>(VT_PLAYER_ID);
  }
  const MyGame::Events::Point3D *pos() const {
    return GetStruct<const MyGame::Events::Point3D *>(VT_POS);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<MyGame::Events::UUID>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<MyGame::Events::Point3D>(verifier, VT_POS, 4) &&
           verifier.EndTable();
  }
  PlayerSpawnT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerSpawnT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PlayerSpawn> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerSpawnT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerSpawnBuilder {
  typedef PlayerSpawn Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_id(const MyGame::Events::UUID *player_id) {
    fbb_.AddStruct(PlayerSpawn::VT_PLAYER_ID, player_id);
  }
  void add_pos(const MyGame::Events::Point3D *pos) {
    fbb_.AddStruct(PlayerSpawn::VT_POS, pos);
  }
  explicit PlayerSpawnBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerSpawn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerSpawn>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerSpawn> CreatePlayerSpawn(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const MyGame::Events::UUID *player_id = nullptr,
    const MyGame::Events::Point3D *pos = nullptr) {
  PlayerSpawnBuilder builder_(_fbb);
  builder_.add_pos(pos);
  builder_.add_player_id(player_id);
  return builder_.Finish();
}

::flatbuffers::Offset<PlayerSpawn> CreatePlayerSpawn(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerSpawnT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerMovedT : public ::flatbuffers::NativeTable {
  typedef PlayerMoved TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MyGame.Events.PlayerMovedT";
  }
  std::unique_ptr<MyGame::Events::UUID> player_id{};
  std::unique_ptr<MyGame::Events::Point3D> pos1{};
  std::unique_ptr<MyGame::Events::Point3D> pos2{};
  PlayerMovedT() = default;
  PlayerMovedT(const PlayerMovedT &o);
  PlayerMovedT(PlayerMovedT&&) FLATBUFFERS_NOEXCEPT = default;
  PlayerMovedT &operator=(PlayerMovedT o) FLATBUFFERS_NOEXCEPT;
};

struct PlayerMoved FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerMovedT NativeTableType;
  typedef PlayerMovedBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MyGame.Events.PlayerMoved";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PLAYER_ID = 4,
    VT_POS1 = 6,
    VT_POS2 = 8
  };
  const MyGame::Events::UUID *player_id() const {
    return GetStruct<const MyGame::Events::UUID *>(VT_PLAYER_ID);
  }
  const MyGame::Events::Point3D *pos1() const {
    return GetStruct<const MyGame::Events::Point3D *>(VT_POS1);
  }
  const MyGame::Events::Point3D *pos2() const {
    return GetStruct<const MyGame::Events::Point3D *>(VT_POS2);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<MyGame::Events::UUID>(verifier, VT_PLAYER_ID, 8) &&
           VerifyField<MyGame::Events::Point3D>(verifier, VT_POS1, 4) &&
           VerifyField<MyGame::Events::Point3D>(verifier, VT_POS2, 4) &&
           verifier.EndTable();
  }
  PlayerMovedT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerMovedT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PlayerMoved> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerMovedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct PlayerMovedBuilder {
  typedef PlayerMoved Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_player_id(const MyGame::Events::UUID *player_id) {
    fbb_.AddStruct(PlayerMoved::VT_PLAYER_ID, player_id);
  }
  void add_pos1(const MyGame::Events::Point3D *pos1) {
    fbb_.AddStruct(PlayerMoved::VT_POS1, pos1);
  }
  void add_pos2(const MyGame::Events::Point3D *pos2) {
    fbb_.AddStruct(PlayerMoved::VT_POS2, pos2);
  }
  explicit PlayerMovedBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerMoved> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerMoved>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerMoved> CreatePlayerMoved(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const MyGame::Events::UUID *player_id = nullptr,
    const MyGame::Events::Point3D *pos1 = nullptr,
    const MyGame::Events::Point3D *pos2 = nullptr) {
  PlayerMovedBuilder builder_(_fbb);
  builder_.add_pos2(pos2);
  builder_.add_pos1(pos1);
  builder_.add_player_id(player_id);
  return builder_.Finish();
}

::flatbuffers::Offset<PlayerMoved> CreatePlayerMoved(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerMovedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct PlayerEventT : public ::flatbuffers::NativeTable {
  typedef PlayerEvent TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MyGame.Events.PlayerEventT";
  }
  uint64_t ts = 0;
  MyGame::Events::EventUnion event{};
};

struct PlayerEvent FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef PlayerEventT NativeTableType;
  typedef PlayerEventBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MyGame.Events.PlayerEvent";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TS = 4,
    VT_EVENT_TYPE = 6,
    VT_EVENT = 8
  };
  uint64_t ts() const {
    return GetField<uint64_t>(VT_TS, 0);
  }
  MyGame::Events::Event event_type() const {
    return static_cast<MyGame::Events::Event>(GetField<uint8_t>(VT_EVENT_TYPE, 0));
  }
  const void *event() const {
    return GetPointer<const void *>(VT_EVENT);
  }
  template<typename T> const T *event_as() const;
  const MyGame::Events::PlayerSpawn *event_as_PlayerSpawn() const {
    return event_type() == MyGame::Events::Event_PlayerSpawn ? static_cast<const MyGame::Events::PlayerSpawn *>(event()) : nullptr;
  }
  const MyGame::Events::PlayerMoved *event_as_PlayerMoved() const {
    return event_type() == MyGame::Events::Event_PlayerMoved ? static_cast<const MyGame::Events::PlayerMoved *>(event()) : nullptr;
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_TS, 8) &&
           VerifyField<uint8_t>(verifier, VT_EVENT_TYPE, 1) &&
           VerifyOffset(verifier, VT_EVENT) &&
           VerifyEvent(verifier, event(), event_type()) &&
           verifier.EndTable();
  }
  PlayerEventT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(PlayerEventT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<PlayerEvent> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

template<> inline const MyGame::Events::PlayerSpawn *PlayerEvent::event_as<MyGame::Events::PlayerSpawn>() const {
  return event_as_PlayerSpawn();
}

template<> inline const MyGame::Events::PlayerMoved *PlayerEvent::event_as<MyGame::Events::PlayerMoved>() const {
  return event_as_PlayerMoved();
}

struct PlayerEventBuilder {
  typedef PlayerEvent Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_ts(uint64_t ts) {
    fbb_.AddElement<uint64_t>(PlayerEvent::VT_TS, ts, 0);
  }
  void add_event_type(MyGame::Events::Event event_type) {
    fbb_.AddElement<uint8_t>(PlayerEvent::VT_EVENT_TYPE, static_cast<uint8_t>(event_type), 0);
  }
  void add_event(::flatbuffers::Offset<void> event) {
    fbb_.AddOffset(PlayerEvent::VT_EVENT, event);
  }
  explicit PlayerEventBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<PlayerEvent> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<PlayerEvent>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<PlayerEvent> CreatePlayerEvent(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t ts = 0,
    MyGame::Events::Event event_type = MyGame::Events::Event_NONE,
    ::flatbuffers::Offset<void> event = 0) {
  PlayerEventBuilder builder_(_fbb);
  builder_.add_ts(ts);
  builder_.add_event(event);
  builder_.add_event_type(event_type);
  return builder_.Finish();
}

::flatbuffers::Offset<PlayerEvent> CreatePlayerEvent(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EventBatchT : public ::flatbuffers::NativeTable {
  typedef EventBatch TableType;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MyGame.Events.EventBatchT";
  }
  std::vector<std::unique_ptr<MyGame::Events::PlayerEventT>> event_batch{};
  EventBatchT() = default;
  EventBatchT(const EventBatchT &o);
  EventBatchT(EventBatchT&&) FLATBUFFERS_NOEXCEPT = default;
  EventBatchT &operator=(EventBatchT o) FLATBUFFERS_NOEXCEPT;
};

struct EventBatch FLATBUFFERS_FINAL_CLASS : private ::flatbuffers::Table {
  typedef EventBatchT NativeTableType;
  typedef EventBatchBuilder Builder;
  static FLATBUFFERS_CONSTEXPR_CPP11 const char *GetFullyQualifiedName() {
    return "MyGame.Events.EventBatch";
  }
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EVENT_BATCH = 4
  };
  const ::flatbuffers::Vector<::flatbuffers::Offset<MyGame::Events::PlayerEvent>> *event_batch() const {
    return GetPointer<const ::flatbuffers::Vector<::flatbuffers::Offset<MyGame::Events::PlayerEvent>> *>(VT_EVENT_BATCH);
  }
  bool Verify(::flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_EVENT_BATCH) &&
           verifier.VerifyVector(event_batch()) &&
           verifier.VerifyVectorOfTables(event_batch()) &&
           verifier.EndTable();
  }
  EventBatchT *UnPack(const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EventBatchT *_o, const ::flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static ::flatbuffers::Offset<EventBatch> Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EventBatchT* _o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EventBatchBuilder {
  typedef EventBatch Table;
  ::flatbuffers::FlatBufferBuilder &fbb_;
  ::flatbuffers::uoffset_t start_;
  void add_event_batch(::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MyGame::Events::PlayerEvent>>> event_batch) {
    fbb_.AddOffset(EventBatch::VT_EVENT_BATCH, event_batch);
  }
  explicit EventBatchBuilder(::flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ::flatbuffers::Offset<EventBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = ::flatbuffers::Offset<EventBatch>(end);
    return o;
  }
};

inline ::flatbuffers::Offset<EventBatch> CreateEventBatch(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    ::flatbuffers::Offset<::flatbuffers::Vector<::flatbuffers::Offset<MyGame::Events::PlayerEvent>>> event_batch = 0) {
  EventBatchBuilder builder_(_fbb);
  builder_.add_event_batch(event_batch);
  return builder_.Finish();
}

inline ::flatbuffers::Offset<EventBatch> CreateEventBatchDirect(
    ::flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<::flatbuffers::Offset<MyGame::Events::PlayerEvent>> *event_batch = nullptr) {
  auto event_batch__ = event_batch ? _fbb.CreateVector<::flatbuffers::Offset<MyGame::Events::PlayerEvent>>(*event_batch) : 0;
  return MyGame::Events::CreateEventBatch(
      _fbb,
      event_batch__);
}

::flatbuffers::Offset<EventBatch> CreateEventBatch(::flatbuffers::FlatBufferBuilder &_fbb, const EventBatchT *_o, const ::flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline PlayerSpawnT::PlayerSpawnT(const PlayerSpawnT &o)
      : player_id((o.player_id) ? new MyGame::Events::UUID(*o.player_id) : nullptr),
        pos((o.pos) ? new MyGame::Events::Point3D(*o.pos) : nullptr) {
}

inline PlayerSpawnT &PlayerSpawnT::operator=(PlayerSpawnT o) FLATBUFFERS_NOEXCEPT {
  std::swap(player_id, o.player_id);
  std::swap(pos, o.pos);
  return *this;
}

inline PlayerSpawnT *PlayerSpawn::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PlayerSpawnT>(new PlayerSpawnT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlayerSpawn::UnPackTo(PlayerSpawnT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player_id(); if (_e) _o->player_id = std::unique_ptr<MyGame::Events::UUID>(new MyGame::Events::UUID(*_e)); }
  { auto _e = pos(); if (_e) _o->pos = std::unique_ptr<MyGame::Events::Point3D>(new MyGame::Events::Point3D(*_e)); }
}

inline ::flatbuffers::Offset<PlayerSpawn> PlayerSpawn::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerSpawnT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerSpawn(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PlayerSpawn> CreatePlayerSpawn(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerSpawnT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PlayerSpawnT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player_id = _o->player_id ? _o->player_id.get() : nullptr;
  auto _pos = _o->pos ? _o->pos.get() : nullptr;
  return MyGame::Events::CreatePlayerSpawn(
      _fbb,
      _player_id,
      _pos);
}

inline PlayerMovedT::PlayerMovedT(const PlayerMovedT &o)
      : player_id((o.player_id) ? new MyGame::Events::UUID(*o.player_id) : nullptr),
        pos1((o.pos1) ? new MyGame::Events::Point3D(*o.pos1) : nullptr),
        pos2((o.pos2) ? new MyGame::Events::Point3D(*o.pos2) : nullptr) {
}

inline PlayerMovedT &PlayerMovedT::operator=(PlayerMovedT o) FLATBUFFERS_NOEXCEPT {
  std::swap(player_id, o.player_id);
  std::swap(pos1, o.pos1);
  std::swap(pos2, o.pos2);
  return *this;
}

inline PlayerMovedT *PlayerMoved::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PlayerMovedT>(new PlayerMovedT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlayerMoved::UnPackTo(PlayerMovedT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = player_id(); if (_e) _o->player_id = std::unique_ptr<MyGame::Events::UUID>(new MyGame::Events::UUID(*_e)); }
  { auto _e = pos1(); if (_e) _o->pos1 = std::unique_ptr<MyGame::Events::Point3D>(new MyGame::Events::Point3D(*_e)); }
  { auto _e = pos2(); if (_e) _o->pos2 = std::unique_ptr<MyGame::Events::Point3D>(new MyGame::Events::Point3D(*_e)); }
}

inline ::flatbuffers::Offset<PlayerMoved> PlayerMoved::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerMovedT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerMoved(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PlayerMoved> CreatePlayerMoved(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerMovedT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PlayerMovedT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _player_id = _o->player_id ? _o->player_id.get() : nullptr;
  auto _pos1 = _o->pos1 ? _o->pos1.get() : nullptr;
  auto _pos2 = _o->pos2 ? _o->pos2.get() : nullptr;
  return MyGame::Events::CreatePlayerMoved(
      _fbb,
      _player_id,
      _pos1,
      _pos2);
}

inline PlayerEventT *PlayerEvent::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<PlayerEventT>(new PlayerEventT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void PlayerEvent::UnPackTo(PlayerEventT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = ts(); _o->ts = _e; }
  { auto _e = event_type(); _o->event.type = _e; }
  { auto _e = event(); if (_e) _o->event.value = MyGame::Events::EventUnion::UnPack(_e, event_type(), _resolver); }
}

inline ::flatbuffers::Offset<PlayerEvent> PlayerEvent::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerEventT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreatePlayerEvent(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<PlayerEvent> CreatePlayerEvent(::flatbuffers::FlatBufferBuilder &_fbb, const PlayerEventT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const PlayerEventT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _ts = _o->ts;
  auto _event_type = _o->event.type;
  auto _event = _o->event.Pack(_fbb);
  return MyGame::Events::CreatePlayerEvent(
      _fbb,
      _ts,
      _event_type,
      _event);
}

inline EventBatchT::EventBatchT(const EventBatchT &o) {
  event_batch.reserve(o.event_batch.size());
  for (const auto &event_batch_ : o.event_batch) { event_batch.emplace_back((event_batch_) ? new MyGame::Events::PlayerEventT(*event_batch_) : nullptr); }
}

inline EventBatchT &EventBatchT::operator=(EventBatchT o) FLATBUFFERS_NOEXCEPT {
  std::swap(event_batch, o.event_batch);
  return *this;
}

inline EventBatchT *EventBatch::UnPack(const ::flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EventBatchT>(new EventBatchT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void EventBatch::UnPackTo(EventBatchT *_o, const ::flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = event_batch(); if (_e) { _o->event_batch.resize(_e->size()); for (::flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { if(_o->event_batch[_i]) { _e->Get(_i)->UnPackTo(_o->event_batch[_i].get(), _resolver); } else { _o->event_batch[_i] = std::unique_ptr<MyGame::Events::PlayerEventT>(_e->Get(_i)->UnPack(_resolver)); }; } } else { _o->event_batch.resize(0); } }
}

inline ::flatbuffers::Offset<EventBatch> EventBatch::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const EventBatchT* _o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEventBatch(_fbb, _o, _rehasher);
}

inline ::flatbuffers::Offset<EventBatch> CreateEventBatch(::flatbuffers::FlatBufferBuilder &_fbb, const EventBatchT *_o, const ::flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { ::flatbuffers::FlatBufferBuilder *__fbb; const EventBatchT* __o; const ::flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _event_batch = _o->event_batch.size() ? _fbb.CreateVector<::flatbuffers::Offset<MyGame::Events::PlayerEvent>> (_o->event_batch.size(), [](size_t i, _VectorArgs *__va) { return CreatePlayerEvent(*__va->__fbb, __va->__o->event_batch[i].get(), __va->__rehasher); }, &_va ) : 0;
  return MyGame::Events::CreateEventBatch(
      _fbb,
      _event_batch);
}

inline bool VerifyEvent(::flatbuffers::Verifier &verifier, const void *obj, Event type) {
  switch (type) {
    case Event_NONE: {
      return true;
    }
    case Event_PlayerSpawn: {
      auto ptr = reinterpret_cast<const MyGame::Events::PlayerSpawn *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Event_PlayerMoved: {
      auto ptr = reinterpret_cast<const MyGame::Events::PlayerMoved *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyEventVector(::flatbuffers::Verifier &verifier, const ::flatbuffers::Vector<::flatbuffers::Offset<void>> *values, const ::flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (::flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyEvent(
        verifier,  values->Get(i), types->GetEnum<Event>(i))) {
      return false;
    }
  }
  return true;
}

inline void *EventUnion::UnPack(const void *obj, Event type, const ::flatbuffers::resolver_function_t *resolver) {
  (void)resolver;
  switch (type) {
    case Event_PlayerSpawn: {
      auto ptr = reinterpret_cast<const MyGame::Events::PlayerSpawn *>(obj);
      return ptr->UnPack(resolver);
    }
    case Event_PlayerMoved: {
      auto ptr = reinterpret_cast<const MyGame::Events::PlayerMoved *>(obj);
      return ptr->UnPack(resolver);
    }
    default: return nullptr;
  }
}

inline ::flatbuffers::Offset<void> EventUnion::Pack(::flatbuffers::FlatBufferBuilder &_fbb, const ::flatbuffers::rehasher_function_t *_rehasher) const {
  (void)_rehasher;
  switch (type) {
    case Event_PlayerSpawn: {
      auto ptr = reinterpret_cast<const MyGame::Events::PlayerSpawnT *>(value);
      return CreatePlayerSpawn(_fbb, ptr, _rehasher).Union();
    }
    case Event_PlayerMoved: {
      auto ptr = reinterpret_cast<const MyGame::Events::PlayerMovedT *>(value);
      return CreatePlayerMoved(_fbb, ptr, _rehasher).Union();
    }
    default: return 0;
  }
}

inline EventUnion::EventUnion(const EventUnion &u) : type(u.type), value(nullptr) {
  switch (type) {
    case Event_PlayerSpawn: {
      value = new MyGame::Events::PlayerSpawnT(*reinterpret_cast<MyGame::Events::PlayerSpawnT *>(u.value));
      break;
    }
    case Event_PlayerMoved: {
      value = new MyGame::Events::PlayerMovedT(*reinterpret_cast<MyGame::Events::PlayerMovedT *>(u.value));
      break;
    }
    default:
      break;
  }
}

inline void EventUnion::Reset() {
  switch (type) {
    case Event_PlayerSpawn: {
      auto ptr = reinterpret_cast<MyGame::Events::PlayerSpawnT *>(value);
      delete ptr;
      break;
    }
    case Event_PlayerMoved: {
      auto ptr = reinterpret_cast<MyGame::Events::PlayerMovedT *>(value);
      delete ptr;
      break;
    }
    default: break;
  }
  value = nullptr;
  type = Event_NONE;
}

inline const MyGame::Events::PlayerEvent *GetPlayerEvent(const void *buf) {
  return ::flatbuffers::GetRoot<MyGame::Events::PlayerEvent>(buf);
}

inline const MyGame::Events::PlayerEvent *GetSizePrefixedPlayerEvent(const void *buf) {
  return ::flatbuffers::GetSizePrefixedRoot<MyGame::Events::PlayerEvent>(buf);
}

inline bool VerifyPlayerEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<MyGame::Events::PlayerEvent>(nullptr);
}

inline bool VerifySizePrefixedPlayerEventBuffer(
    ::flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<MyGame::Events::PlayerEvent>(nullptr);
}

inline void FinishPlayerEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MyGame::Events::PlayerEvent> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedPlayerEventBuffer(
    ::flatbuffers::FlatBufferBuilder &fbb,
    ::flatbuffers::Offset<MyGame::Events::PlayerEvent> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<MyGame::Events::PlayerEventT> UnPackPlayerEvent(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MyGame::Events::PlayerEventT>(GetPlayerEvent(buf)->UnPack(res));
}

inline std::unique_ptr<MyGame::Events::PlayerEventT> UnPackSizePrefixedPlayerEvent(
    const void *buf,
    const ::flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<MyGame::Events::PlayerEventT>(GetSizePrefixedPlayerEvent(buf)->UnPack(res));
}

}  // namespace Events
}  // namespace MyGame

#endif  // FLATBUFFERS_GENERATED_PLAYEREVENTS_MYGAME_EVENTS_H_
